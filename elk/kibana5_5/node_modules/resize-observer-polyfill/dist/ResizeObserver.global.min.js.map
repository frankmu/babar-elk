{"version":3,"file":null,"sources":["../src/ResizeObservation.js","../src/ResizeObserverEntry.js","../src/shims/es6-collections.js","../src/shims/requestAnimationFrame.js","../src/throttle.js","../src/ResizeObserverController.js","../src/_ResizeObserver.js","../src/ResizeObserver.js","../index.global.js"],"sourcesContent":["// Placeholder of an empty content rectangle.\r\nconst emptyRect = createContentRect(0, 0, 0, 0);\r\n\r\n/**\r\n * Extracts computed styles of provided element.\r\n *\r\n * @param {Element} target\r\n * @returns {CSSStyleDeclaration}\r\n */\r\nfunction getStyles(target) {\r\n    return window.getComputedStyle(target);\r\n}\r\n\r\n/**\r\n * Converts provided string defined in q form of '{{value}}px' to number.\r\n *\r\n * @param {String} value\r\n * @returns {Number}\r\n */\r\nfunction pixelsToNumber(value) {\r\n    return parseFloat(value) || 0;\r\n}\r\n\r\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...String} positions - Borders positions (top, right, ...)\r\n * @returns {Number}\r\n */\r\nfunction getBordersSize(styles, ...positions) {\r\n    return positions.reduce((size, pos) => {\r\n        const value = styles['border-' + pos + '-width'];\r\n\r\n        return size + pixelsToNumber(value);\r\n    }, 0);\r\n}\r\n\r\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\r\nfunction getPaddings(styles) {\r\n    const boxKeys = ['top', 'right', 'bottom', 'left'];\r\n    const paddings = {};\r\n\r\n    for (const key of boxKeys) {\r\n        const value = styles['padding-' + key];\r\n\r\n        paddings[key] = pixelsToNumber(value);\r\n    }\r\n\r\n    return paddings;\r\n}\r\n\r\n/**\r\n * Creates content rectangle based on the provided dimensions\r\n * and the top/left positions.\r\n *\r\n * @param {Number} width - Width of rectangle.\r\n * @param {Number} height - Height of rectangle.\r\n * @param {Number} top - Top position.\r\n * @param {Number} left - Left position.\r\n * @returns {ClientRect}\r\n */\r\nfunction createContentRect(width, height, top, left) {\r\n    return {\r\n        width, height, top,\r\n        right: width + left,\r\n        bottom: height + top,\r\n        left\r\n    };\r\n}\r\n\r\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGElement} target - Element whose content\r\n *      rectangle needs to be calculated.\r\n * @returns {ClientRect}\r\n */\r\nfunction getSVGContentRect(target) {\r\n    const bbox = target.getBBox();\r\n\r\n    return createContentRect(bbox.width, bbox.height, 0, 0);\r\n}\r\n\r\n/**\r\n * Calculates content rectangle of a root element.\r\n *\r\n * @returns {ClientRect}\r\n */\r\nfunction getDocElementRect() {\r\n    // Neither scroll[Width/Height] nor offset[Width/Height] can be used to\r\n    // define content dimensions as they give inconsistent results across\r\n    // different browsers. E.g. in the Internet Explorer 10 and lower value of\r\n    // these properties can't be less than the client dimensions (same thing\r\n    // with the \"getBoundingClientRect\" method). And Firefox has the same\r\n    // behavior with its \"scroll\" properties.\r\n    const styles = getStyles(document.documentElement);\r\n\r\n    const width = pixelsToNumber(styles.width);\r\n    const height = pixelsToNumber(styles.height);\r\n\r\n    return createContentRect(width, height, 0, 0);\r\n}\r\n\r\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element whose content\r\n *      rectangle needs to be calculated.\r\n * @returns {ClientRect}\r\n */\r\nfunction getHTMLElementContentRect(target) {\r\n    // Client width & height properties can't be\r\n    // used exclusively as they provide rounded values.\r\n    const clientWidth = target.clientWidth;\r\n    const clientHeight = target.clientHeight;\r\n\r\n    // By this condition we can catch all non-replaced inline, hidden and detached\r\n    // elements. Though elements with width & height properties less than 0.5 will\r\n    // be discarded as well.\r\n    //\r\n    // Without it we would need to implement separate methods for each of\r\n    // those cases and it's not possible to perform a precise and performance\r\n    // effective test for hidden elements. E.g. even jQuerys' ':visible' filter\r\n    // gives wrong results for elements with width & height less than 0.5.\r\n    if (!clientWidth && !clientHeight) {\r\n        return emptyRect;\r\n    }\r\n\r\n    const styles = getStyles(target);\r\n    const paddings = getPaddings(styles);\r\n    const horizPad = paddings.left + paddings.right;\r\n    const vertPad = paddings.top + paddings.bottom;\r\n\r\n    // Computed styles of width & height are being used because they are the\r\n    // only dimensions available to JS that contain non-rounded values. It could\r\n    // be possible to utilize getBoundingClientRect if only its' data wasn't\r\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\r\n    let width = pixelsToNumber(styles.width),\r\n        height = pixelsToNumber(styles.height);\r\n\r\n    // Width & height include paddings and borders\r\n    // when 'border-box' box model is applied (except for IE).\r\n    if (styles.boxSizing === 'border-box') {\r\n        // Following conditions are required to handle Internet Explorer which\r\n        // doesn't include paddings and borders to computed CSS dimensions.\r\n        //\r\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\r\n        // properties then it's either IE, and thus we don't need to subtract\r\n        // anything, or an element merely doesn't have paddings/borders styles.\r\n        if (Math.round(width + horizPad) !== clientWidth) {\r\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\r\n        }\r\n\r\n        if (Math.round(height + vertPad) !== clientHeight) {\r\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\r\n        }\r\n    }\r\n\r\n    // In some browsers (only in Firefox, actually) CSS width & height\r\n    // include scroll bars size which can be removed at this step as scroll bars\r\n    // are the only difference between rounded dimensions + paddings and \"client\"\r\n    // properties, though that is not always true in Chrome.\r\n    const vertScrollbar = Math.round(width + horizPad) - clientWidth;\r\n    const horizScrollbar = Math.round(height + vertPad) - clientHeight;\r\n\r\n    // Chrome has a rather weird rounding of \"client\" properties.\r\n    // E.g. for an element with content width of 314.2px it sometimes gives the\r\n    // client width of 315px and for the width of 314.7px it may give 314px.\r\n    // And it doesn't happen all the time. Such difference needs to be ignored.\r\n    if (Math.abs(vertScrollbar) !== 1) {\r\n        width -= vertScrollbar;\r\n    }\r\n\r\n    if (Math.abs(horizScrollbar) !== 1) {\r\n        height -= horizScrollbar;\r\n    }\r\n\r\n    return createContentRect(width, height, paddings.top, paddings.left);\r\n}\r\n\r\n/**\r\n * Checks whether provided element is an instance of SVGElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {Boolean}\r\n */\r\nfunction isSVGElement(target) {\r\n    return target instanceof window.SVGElement;\r\n}\r\n\r\n/**\r\n * Checks whether provided element is a document element (root element of a document).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {Boolean}\r\n */\r\nfunction isDocumentElement(target) {\r\n    return target === document.documentElement;\r\n}\r\n\r\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element whose content rectangle\r\n *      needs to be calculated.\r\n * @returns {ClientRect}\r\n */\r\nfunction getContentRect(target) {\r\n    if (isSVGElement(target)) {\r\n        return getSVGContentRect(target);\r\n    }\r\n\r\n    if (isDocumentElement(target)) {\r\n        return getDocElementRect();\r\n    }\r\n\r\n    return getHTMLElementContentRect(target);\r\n}\r\n\r\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of its' changes.\r\n */\r\nexport default class ResizeObservation {\r\n    /**\r\n     * Creates an instance of ResizeObservation.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     */\r\n    constructor(target) {\r\n        this.target = target;\r\n\r\n        // Keeps reference to the last observed content rectangle.\r\n        this._contentRect = emptyRect;\r\n\r\n        // Broadcasted width of content rectangle.\r\n        this.broadcastWidth = 0;\r\n\r\n        // Broadcasted height of content rectangle.\r\n        this.broadcastHeight = 0;\r\n    }\r\n\r\n    /**\r\n     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n     * from the corresponding properties of the last observed content rectangle.\r\n     *\r\n     * @returns {ClientRect} Last observed content rectangle.\r\n     */\r\n    broadcastRect() {\r\n        const rect = this._contentRect;\r\n\r\n        this.broadcastWidth = rect.width;\r\n        this.broadcastHeight = rect.height;\r\n\r\n        return rect;\r\n    }\r\n\r\n    /**\r\n     * Updates content rectangle and tells whether its' width or height properties\r\n     * have changed since the last broadcast.\r\n     *\r\n     * @returns {Boolean}\r\n     */\r\n    isActive() {\r\n        const rect = getContentRect(this.target);\r\n\r\n        this._contentRect = rect;\r\n\r\n        return (\r\n            rect.width !== this.broadcastWidth ||\r\n            rect.height !== this.broadcastHeight\r\n        );\r\n    }\r\n}\r\n","/**\r\n * Defines properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @param {Object} [descr = {}] - Properties descriptor.\r\n * @returns {Object} Target object.\r\n */\r\nfunction defineProperties(target, props, descr = {}) {\r\n    const descriptor = {\r\n        configurable: descr.configurable || false,\r\n        writable: descr.writable || false,\r\n        enumerable: descr.enumerable || false\r\n    };\r\n\r\n    for (const key of Object.keys(props)) {\r\n        descriptor.value = props[key];\r\n\r\n        Object.defineProperty(target, key, descriptor);\r\n    }\r\n\r\n    return target;\r\n}\r\n\r\nexport default class ResizeObserverEntry {\r\n    /**\r\n     * Creates an instance of ResizeObserverEntry.\r\n     *\r\n     * @param {Element} target - Element that is being observed.\r\n     * @param {ClientRect} rectData - Data of the elements' content rectangle.\r\n     */\r\n    constructor(target, rectData) {\r\n        // Content rectangle needs to be an instance of ClientRect if it's\r\n        // available.\r\n        const rectInterface = window.ClientRect || Object;\r\n        const contentRect = Object.create(rectInterface.prototype);\r\n\r\n        // According to the specification following properties are not writable\r\n        // and are also not enumerable in the native implementation.\r\n        //\r\n        // Property accessors are not being used as they'd require to define a\r\n        // private WeakMap storage which may cause memory leaks in browsers that\r\n        // don't support this type of collections.\r\n        defineProperties(contentRect, rectData, {configurable: true});\r\n\r\n        defineProperties(this, {\r\n            target, contentRect\r\n        }, {configurable: true});\r\n    }\r\n}\r\n","/**\r\n * A collection of shims that provides minimal\r\n * support of WeakMap and Map classes.\r\n *\r\n * These implementations are not meant to be used outside of\r\n * ResizeObserver modules as they cover only a limited range\r\n * of use cases.\r\n */\r\n\r\n/* eslint-disable require-jsdoc */\r\nconst hasNativeCollections =\r\n    typeof window.WeakMap === 'function' &&\r\n    typeof window.Map === 'function';\r\n\r\nconst WeakMap = (() => {\r\n    if (hasNativeCollections) {\r\n        return window.WeakMap;\r\n    }\r\n\r\n    function getIndex(arr, key) {\r\n        let result = -1;\r\n\r\n        arr.some((entry, index) => {\r\n            let matches = entry[0] === key;\r\n\r\n            if (matches) {\r\n                result = index;\r\n            }\r\n\r\n            return matches;\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    return class {\r\n        constructor() {\r\n            this.__entries__ = [];\r\n        }\r\n\r\n        get(key) {\r\n            let index = getIndex(this.__entries__, key);\r\n\r\n            return this.__entries__[index][1];\r\n        }\r\n\r\n        set(key, value) {\r\n            let index = getIndex(this.__entries__, key);\r\n\r\n            if (~index) {\r\n                this.__entries__[index][1] = value;\r\n            } else {\r\n                this.__entries__.push([key, value]);\r\n            }\r\n        }\r\n\r\n        delete(key) {\r\n            let entries = this.__entries__,\r\n                index = getIndex(entries, key);\r\n\r\n            if (~index) {\r\n                entries.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        has(key) {\r\n            return !!~getIndex(this.__entries__, key);\r\n        }\r\n    };\r\n})();\r\n\r\nconst Map = (() => {\r\n    if (hasNativeCollections) {\r\n        return window.Map;\r\n    }\r\n\r\n    return class extends WeakMap {\r\n        get size() {\r\n            return this.__entries__.length;\r\n        }\r\n\r\n        clear() {\r\n            this.__entries__.splice(0, this.__entries__.length);\r\n        }\r\n\r\n        entries() {\r\n            return this.__entries__.slice();\r\n        }\r\n\r\n        keys() {\r\n            return this.__entries__.map(entry => entry[0]);\r\n        }\r\n\r\n        values() {\r\n            return this.__entries__.map(entry => entry[1]);\r\n        }\r\n\r\n        forEach(callback, ctx = null) {\r\n            for (const entry of this.__entries__) {\r\n                callback.call(ctx, entry[1], entry[0]);\r\n            }\r\n        }\r\n    };\r\n})();\r\n\r\nexport {Map, WeakMap};\r\n","/**\r\n * A shim for requestAnimationFrame which falls back\r\n * to setTimeout if the first one is not supported.\r\n *\r\n * @returns {Number} Requests' identifier.\r\n */\r\nexport default (() => {\r\n    if (typeof window.requestAnimationFrame === 'function') {\r\n        return window.requestAnimationFrame;\r\n    }\r\n\r\n    return callback => {\r\n        return setTimeout(() => callback(Date.now()), 1000 / 60);\r\n    };\r\n})();\r\n","import reqAnimFrame from './shims/requestAnimationFrame';\r\n\r\n/**\r\n * Creates a wrapper function that ensures that provided callback will\r\n * be invoked only once during the specified delay period. It caches the last\r\n * call and re-invokes it after pending activation is resolved.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {Number} [delay = 0] - Delay after which to invoke callback.\r\n * @param {Boolean} [afterRAF = false] - Whether function needs to be invoked as\r\n *      a requestAnimationFrame callback.\r\n * @returns {Function}\r\n */\r\nexport default function (callback, delay = 0, afterRAF = false) {\r\n    let leadCall = null,\r\n        edgeCall = null;\r\n\r\n    /**\r\n     * Invokes the original callback function and schedules a new invocation if\r\n     * the wrapper was called during current request.\r\n     */\r\n    function invokeCallback() {\r\n        // Invoke original function.\r\n        callback.apply(...leadCall);\r\n\r\n        leadCall = null;\r\n\r\n        // Schedule new invocation if there was a call during delay period.\r\n        if (edgeCall) {\r\n            proxy.apply(...edgeCall);\r\n\r\n            edgeCall = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback that will be invoked after the specified delay period. It will\r\n     * delegate invocation of the original function to the requestAnimationFrame\r\n     * if \"afterRAF\" parameter is set to \"true\".\r\n     */\r\n    function timeoutCallback() {\r\n        afterRAF ? reqAnimFrame(invokeCallback) : invokeCallback();\r\n    }\r\n\r\n    /**\r\n     * Schedules invocation of the initial function.\r\n     */\r\n    function proxy(...args) {\r\n        // eslint-disable-next-line no-invalid-this\r\n        const callData = [this, args];\r\n\r\n        // Cache current call to be re-invoked later if there is already a\r\n        // pending call.\r\n        if (leadCall) {\r\n            edgeCall = callData;\r\n        } else {\r\n            leadCall = callData;\r\n\r\n            // Schedule new invocation.\r\n            setTimeout(timeoutCallback, delay);\r\n        }\r\n    }\r\n\r\n    return proxy;\r\n}\r\n","import throttle from './throttle';\r\n\r\n// Define whether the MutationObserver is supported.\r\nconst mutationsSupported = typeof window.MutationObserver === 'function';\r\n\r\n/**\r\n * Controller class which handles updates of ResizeObserver instances.\r\n * It decides when and for how long it's necessary to run updates by listening\r\n * to the windows \"resize\" event along with a tracking of DOM mutations\r\n * (nodes removal, changes of attributes, etc.).\r\n *\r\n * Transitions and animations are handled by running a repeatable update cycle\r\n * until the dimensions of observed elements are changing.\r\n *\r\n * Continuous update cycle will be used automatically in case MutationObserver\r\n * is not supported.\r\n */\r\nexport default class ResizeObserverController {\r\n    /**\r\n     * Creates a new instance of ResizeObserverController.\r\n     *\r\n     * @param {Boolean} [continuousUpdates = false] - Whether to use a continuous\r\n     *      update cycle.\r\n     */\r\n    constructor(continuousUpdates = false) {\r\n        // Continuous updates must be enabled if MutationObserver is not supported.\r\n        this._isCycleContinuous = !mutationsSupported || continuousUpdates;\r\n\r\n        // Indicates whether DOM listeners have been added.\r\n        this._listenersEnabled = false;\r\n\r\n        // Keeps reference to the instance of MutationObserver.\r\n        this._mutationsObserver = null;\r\n\r\n        // A list of connected observers.\r\n        this._observers = [];\r\n\r\n        // Make sure that the \"refresh\" method is invoked as a RAF callback and\r\n        // that it happens only once during the period of 30 milliseconds.\r\n        this.refresh = throttle(this.refresh.bind(this), 30, true);\r\n\r\n        // Additionally postpone invocation of the continuous updates.\r\n        this._continuousUpdateHandler = throttle(this.refresh, 70);\r\n    }\r\n\r\n    /**\r\n     * Tells whether continuous updates are enabled.\r\n     *\r\n     * @returns {Boolean}\r\n     */\r\n    get continuousUpdates() {\r\n        return this._isCycleContinuous;\r\n    }\r\n\r\n    /**\r\n     * Enables or disables continuous updates.\r\n     *\r\n     * @param {Boolean} useContinuous - Whether to enable or disable continuous\r\n     *      updates. Note that the value won't be applied if MutationObserver is\r\n     *      not supported.\r\n     */\r\n    set continuousUpdates(useContinuous) {\r\n        // The state of continuous updates should not be modified if\r\n        // MutationObserver is not supported.\r\n        if (!mutationsSupported) {\r\n            return;\r\n        }\r\n\r\n        this._isCycleContinuous = useContinuous;\r\n\r\n        // Immediately start the update cycle in order not to wait for a possible\r\n        // event that might initiate it.\r\n        if (this._listenersEnabled && useContinuous) {\r\n            this.refresh();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds observer to observers list.\r\n     *\r\n     * @param {ResizeObserver} observer - Observer to be added.\r\n     */\r\n    connect(observer) {\r\n        if (!this.isConnected(observer)) {\r\n            this._observers.push(observer);\r\n        }\r\n\r\n        // Add listeners if they haven't been added yet.\r\n        if (!this._listenersEnabled) {\r\n            this._addListeners();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes observer from observers list.\r\n     *\r\n     * @param {ResizeObserver} observer - Observer to be removed.\r\n     */\r\n    disconnect(observer) {\r\n        const observers = this._observers;\r\n        const index = observers.indexOf(observer);\r\n\r\n        // Remove observer if it's present in registry.\r\n        if (~index) {\r\n            observers.splice(index, 1);\r\n        }\r\n\r\n        // Remove listeners if controller has no connected observers.\r\n        if (!observers.length && this._listenersEnabled) {\r\n            this._removeListeners();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Tells whether the provided observer is connected to controller.\r\n     *\r\n     * @param {ResizeObserver} observer - Observer to be checked.\r\n     * @returns {Boolean}\r\n     */\r\n    isConnected(observer) {\r\n        return !!~this._observers.indexOf(observer);\r\n    }\r\n\r\n    /**\r\n     * Invokes the update of observers. It will continue running updates insofar\r\n     * it detects changes or if continuous updates are enabled.\r\n     */\r\n    refresh() {\r\n        const hasChanges = this._updateObservers();\r\n\r\n        // Continue running updates if changes have been detected as there might\r\n        // be future ones caused by CSS transitions.\r\n        if (hasChanges) {\r\n            this.refresh();\r\n        } else if (this._isCycleContinuous && this._listenersEnabled) {\r\n            // Automatically repeat cycle if it's necessary.\r\n            this._continuousUpdateHandler();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates every observer from observers list and notifies them of queued\r\n     * entries.\r\n     *\r\n     * @private\r\n     * @returns {Boolean} Returns \"true\" if any observer has detected changes in\r\n     *      dimensions of its' elements.\r\n     */\r\n    _updateObservers() {\r\n        let hasChanges = false;\r\n\r\n        for (const observer of this._observers) {\r\n            // Collect active observations.\r\n            observer.gatherActive();\r\n\r\n            // Broadcast active observations and set the flag that changes have\r\n            // been detected.\r\n            if (observer.hasActive()) {\r\n                hasChanges = true;\r\n\r\n                observer.broadcastActive();\r\n            }\r\n        }\r\n\r\n        return hasChanges;\r\n    }\r\n\r\n    /**\r\n     * Initializes DOM listeners.\r\n     *\r\n     * @private\r\n     */\r\n    _addListeners() {\r\n        // Do nothing if listeners have been already added.\r\n        if (this._listenersEnabled) {\r\n            return;\r\n        }\r\n\r\n        window.addEventListener('resize', this.refresh);\r\n\r\n        // Subscribe to DOM mutations if it's possible as they may lead to\r\n        // changes in the dimensions of elements.\r\n        if (mutationsSupported) {\r\n            this._mutationsObserver = new MutationObserver(this.refresh);\r\n\r\n            this._mutationsObserver.observe(document, {\r\n                attributes: true,\r\n                childList: true,\r\n                characterData: true,\r\n                subtree: true\r\n            });\r\n        }\r\n\r\n        this._listenersEnabled = true;\r\n\r\n        // Don't wait for a possible event that might trigger the update of\r\n        // observers and manually initiate the update process.\r\n        if (this._isCycleContinuous) {\r\n            this.refresh();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes DOM listeners.\r\n     *\r\n     * @private\r\n     */\r\n    _removeListeners() {\r\n        // Do nothing if listeners have been already removed.\r\n        if (!this._listenersEnabled) {\r\n            return;\r\n        }\r\n\r\n        window.removeEventListener('resize', this.refresh);\r\n\r\n        if (this._mutationsObserver) {\r\n            this._mutationsObserver.disconnect();\r\n        }\r\n\r\n        this._mutationsObserver = null;\r\n        this._listenersEnabled = false;\r\n    }\r\n}\r\n","import {Map} from './shims/es6-collections';\r\nimport ResizeObservation from './ResizeObservation';\r\nimport ResizeObserverEntry from './ResizeObserverEntry';\r\n\r\nexport default class ResizeObserver {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {Function} callback - Callback function that is invoked when one\r\n     *      of the observed elements changes it's content rectangle.\r\n     * @param {ResizeObsreverController} controller - Controller instance which\r\n     *      is responsible for the updates of observer.\r\n     * @param {ResizeObserver} publicObserver - Reference to the public\r\n     *      ResizeObserver instance which will be passed to callback function.\r\n     */\r\n    constructor(callback, controller, publicObserver) {\r\n        if (typeof callback !== 'function') {\r\n            throw new TypeError('The callback provided as parameter 1 is not a function.');\r\n        }\r\n\r\n        // Reference to the callback function.\r\n        this._callback = callback;\r\n\r\n        // Registry of ResizeObservation instances.\r\n        this._targets = new Map();\r\n\r\n        // Collection of resize observations that have detected changes in\r\n        // dimensions of elements.\r\n        this._activeTargets = [];\r\n\r\n        // Reference to the associated ResizeObserverController.\r\n        this._controller = controller;\r\n\r\n        // Public ResizeObserver instance which will be passed to callback function.\r\n        this._publicObserver = publicObserver;\r\n    }\r\n\r\n    /**\r\n     * Starts observing provided element.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     */\r\n    observe(target) {\r\n        //  Throw the same errors as in a native implementation.\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n\r\n        if (!(target instanceof Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n\r\n        const targets = this._targets;\r\n\r\n        // Do nothing if element is already being observed.\r\n        if (targets.has(target)) {\r\n            return;\r\n        }\r\n\r\n        // Register new ResizeObservation instance.\r\n        targets.set(target, new ResizeObservation(target));\r\n\r\n        // Add observer to controller if it hasn't been connected yet.\r\n        if (!this._controller.isConnected(this)) {\r\n            this._controller.connect(this);\r\n        }\r\n\r\n        // Update observations.\r\n        this._controller.refresh();\r\n    }\r\n\r\n    /**\r\n     * Stops observing provided element.\r\n     *\r\n     * @param {Element} target - Element to stop observing.\r\n     */\r\n    unobserve(target) {\r\n        //  Throw the same errors as in a native implementation.\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n\r\n        if (!(target instanceof Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n\r\n        const targets = this._targets;\r\n\r\n        // Do nothing if element is not being observed.\r\n        if (!targets.has(target)) {\r\n            return;\r\n        }\r\n\r\n        // Remove element and associated with it ResizeObsrvation instance from\r\n        // registry.\r\n        targets.delete(target);\r\n\r\n        // Set back the initial state if there is nothing to observe.\r\n        if (!targets.size) {\r\n            this.disconnect();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops observing all elements and clears the observations list.\r\n     */\r\n    disconnect() {\r\n        this.clearActive();\r\n        this._targets.clear();\r\n        this._controller.disconnect(this);\r\n    }\r\n\r\n    /**\r\n     * Clears an array of previously collected active observations and collects\r\n     * observation instances which associated element has changed its' content\r\n     * rectangle.\r\n     */\r\n    gatherActive() {\r\n        this.clearActive();\r\n\r\n        const activeTargets = this._activeTargets;\r\n\r\n        this._targets.forEach(observation => {\r\n            if (observation.isActive()) {\r\n                activeTargets.push(observation);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Invokes initial callback function with a list of ResizeObserverEntry\r\n     * instances collected from active resize observations.\r\n     */\r\n    broadcastActive() {\r\n        // Do nothing if observer doesn't have active observations.\r\n        if (!this.hasActive()) {\r\n            return;\r\n        }\r\n\r\n        const observer = this._publicObserver;\r\n\r\n        // Create ResizeObserverEntry instance for every active observation.\r\n        const entries = this._activeTargets.map(observation => {\r\n            return new ResizeObserverEntry(\r\n                observation.target,\r\n                observation.broadcastRect()\r\n            );\r\n        });\r\n\r\n        this.clearActive();\r\n        this._callback.call(observer, entries, observer);\r\n    }\r\n\r\n    /**\r\n     * Clears the collection of pending/active observations.\r\n     */\r\n    clearActive() {\r\n        this._activeTargets.splice(0);\r\n    }\r\n\r\n    /**\r\n     * Tells whether observer has pending observations.\r\n     *\r\n     * @returns {Boolean}\r\n     */\r\n    hasActive() {\r\n        return !!this._activeTargets.length;\r\n    }\r\n}\r\n","import {WeakMap} from './shims/es6-collections';\r\nimport ResizeObserverController from './ResizeObserverController';\r\nimport _ResizeObserver from './_ResizeObserver';\r\n\r\n// Controller that will be assigned to all instances of ResizeObserver.\r\nconst controller = new ResizeObserverController();\r\n\r\n// Registry of the internal observers.\r\nconst observers = new WeakMap();\r\n\r\n/**\r\n * ResizeObservers' \"Proxy\" class which is meant to hide private properties and\r\n * methods from public instances.\r\n *\r\n * Additionally implements the \"continuousUpdates\" static property accessor to\r\n * give control over the behavior of the ResizeObserverController instance.\r\n * Changes made to this property affect all future and existing observers.\r\n */\r\nclass ResizeObserver {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {Function} callback - Callback that is invoked when dimensions of\r\n     *      one of the observed elements change.\r\n     */\r\n    constructor(callback) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n\r\n        // Create a new instance of the internal ResizeObserver.\r\n        const observer = new _ResizeObserver(callback, controller, this);\r\n\r\n        // Register internal observer.\r\n        observers.set(this, observer);\r\n    }\r\n\r\n    /**\r\n     * Tells whether continuous updates are enabled.\r\n     *\r\n     * @returns {Boolean}\r\n     */\r\n    static get continuousUpdates() {\r\n        return controller.continuousUpdates;\r\n    }\r\n\r\n    /**\r\n     * Enables or disables continuous updates.\r\n     *\r\n     * @param {Boolean} value - Whether to enable or disable continuous updates.\r\n     */\r\n    static set continuousUpdates(value) {\r\n        if (typeof value !== 'boolean') {\r\n            throw new TypeError('type of \"continuousUpdates\" value must be boolean.');\r\n        }\r\n\r\n        controller.continuousUpdates = value;\r\n    }\r\n}\r\n\r\n// Expose public methods of ResizeObserver.\r\n[\r\n    'observe',\r\n    'unobserve',\r\n    'disconnect'\r\n].forEach(method => {\r\n    ResizeObserver.prototype[method] = function () {\r\n        return observers.get(this)[method](...arguments);\r\n    };\r\n});\r\n\r\nexport default ResizeObserver;\r\n","import ResizeObserver from './src/ResizeObserver';\r\n\r\nif (typeof window.ResizeObserver !== 'function') {\r\n    // ResizeObserver host property is not enumerable\r\n    // in the native implementation.\r\n    Object.defineProperty(window, 'ResizeObserver', {\r\n        value: ResizeObserver,\r\n        writable: true,\r\n        configurable: true\r\n    });\r\n}\r\n\r\n// Still export the constructor as for me it seems\r\n// awkward when a module doesn't export anything.\r\nexport default window.ResizeObserver;\r\n"],"names":["getStyles","target","window","getComputedStyle","pixelsToNumber","value","parseFloat","getBordersSize","styles","positions","reduce","size","pos","getPaddings","boxKeys","paddings","key","createContentRect","width","height","top","left","getSVGContentRect","bbox","getBBox","getDocElementRect","document","documentElement","getHTMLElementContentRect","clientWidth","clientHeight","emptyRect","horizPad","right","vertPad","bottom","boxSizing","Math","round","vertScrollbar","horizScrollbar","abs","isSVGElement","SVGElement","isDocumentElement","getContentRect","defineProperties","props","descr","descriptor","configurable","writable","enumerable","Object","keys","defineProperty","hasNativeCollections","WeakMap","Map","getIndex","arr","result","some","entry","index","matches","__entries__","get","this","set","push","delete","entries","splice","has","clear","length","slice","map","values","forEach","callback","ctx","call","requestAnimationFrame","setTimeout","Date","now","invokeCallback","apply","leadCall","edgeCall","timeoutCallback","reqAnimFrame","proxy","args","callData","delay","afterRAF","mutationsSupported","MutationObserver","ResizeObserverController","continuousUpdates","_isCycleContinuous","_listenersEnabled","_mutationsObserver","_observers","refresh","throttle","bind","_continuousUpdateHandler","connect","observer","isConnected","_addListeners","disconnect","observers","indexOf","_removeListeners","hasChanges","_updateObservers","gatherActive","hasActive","broadcastActive","addEventListener","observe","removeEventListener","useContinuous","ResizeObservation","_contentRect","broadcastWidth","broadcastHeight","broadcastRect","rect","isActive","ResizeObserverEntry","rectData","rectInterface","ClientRect","contentRect","create","prototype","ResizeObserver","controller","publicObserver","TypeError","_callback","_targets","_activeTargets","_controller","_publicObserver","arguments","Element","targets","unobserve","clearActive","activeTargets","observation","_ResizeObserver","method"],"mappings":"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"}