{
   "new_job_id": {
      "text": "Unique identifier for job, can use lowercase alphanumeric and underscores."
   },
   "new_job_description": {
      "text": "Optional descriptive text."
   },
   "new_job_custom_urls": {
      "text": "Optional drill-through links to source data. Supports string substitution for analyzed fields e.g. $hostname$."
   },
   "new_job_bucketspan": {
      "text": "Interval for time series analysis."
   },
   "new_job_sparsedata": {
      "text": "Check if you wish to ignore empty buckets from being considered anomalous."
   },
   "new_job_summarycountfieldname": {
      "text": "Optional, for use if input data has been pre-summarized e.g. doc_count."
   },
   "new_job_categorizationfieldname": {
      "text": "Optional, for use if analyzing unstructured log data. Using text data types is recommended."
   },
   "new_job_categorizationfilters": {
      "text": "Optional, apply regular expressions to the categorization field"
   },
   "new_job_detectors": {
      "text": "Defines the fields and functions used for analysis."
   },
   "new_job_influencers": {
      "text": "Select which categorical fields have influence on the results. Who/what might you \"blame\" for an anomaly? Recommend 1-3 influencers."
   },
   "new_job_detector_description": {
      "text": "User-friendly text used for dashboards."
   },
   "new_job_detector_function": {
      "text": "Analysis functions to be performed e.g. sum, count."
   },
   "new_job_detector_fieldname": {
      "text": "Required for functions: sum, mean, median, max, min, info_content, distinct_count."
   },
   "new_job_detector_fieldname_subset": {
      "text": "Required for functions: sum, mean, max, min, distinct_count."
   },
   "new_job_detector_byfieldname": {
      "text": "Required for individual analysis where anomalies are detected compared to an entity's own past behavior."
   },
   "new_job_detector_overfieldname": {
      "text": "Required for population analysis where anomalies are detected compared to the behavior of the population."
   },
   "new_job_detector_partitionfieldname": {
      "text": "Allows segmentation of modeling into logical groups."
   },
   "new_job_detector_excludefrequent": {
      "text": "If true will automatically identify and exclude frequently occurring entities which may otherwise have dominated results."
   },
   "new_job_data_format": {
      "text": "Describes the format of the input data: delimited, JSON, single line or Elasticsearch."
   },
   "new_job_time_field": {
      "text": "Name of the field containing the timestamp."
   },
   "new_job_time_format": {
      "text": "Format of the time field: epoch, epoch_ms or Java DateTimeFormatter string. Important to get right."
   },
   "new_job_delimiter": {
      "text": "Character used to separate fields."
   },
   "new_job_quote_character": {
      "text": "Character used to encapsulate values containing reserved characters."
   },
   "new_job_enable_datafeed_job": {
      "text": "Required for jobs that analyze data from Elasticsearch.\nRequires data format to be set to Elasticsearch"
   },
   "new_job_data_source": {
      "text": "Elasticsearch versions 1.7.x and 2+ supported."
   },
   "new_job_datafeed_query": {
      "text": "Elasticsearch Query DSL for filtering input data."
   },
   "new_job_datafeed_query_delay": {
      "text": "Advanced option. Time delay in seconds, between current time and latest input data time."
   },
   "new_job_datafeed_frequency": {
      "text": "Advanced option. The interval between searches."
   },
   "new_job_datafeed_scrollsize": {
      "text": "Advanced option. The maximum number of documents requested for a search."
   },
   "new_job_data_preview": {
      "text": "This preview returns the contents of the source field only."
   },
   "new_job_elasticsearch_server": {
      "text": "Server address and port of Elasticsearch source."
   },
   "new_job_enable_authenticated": {
      "text": "Select to specify username and password for secure access."
   },
   "new_job_datafeed_retrieve_source": {
      "text": "Advanced option. Select to retrieve unfiltered _source document, instead of specified fields."
   },
   "new_job_advanced_settings": {
      "text": "Advanced options"
   },
   "new_job_dedicated_index": {
      "text": "Select to store results in a separate index for this job"
   },
   "new_filter_ruleaction": {
      "text": "A string specifying the rule action. Initially, the only valid option is 'filter_results' but it provisions for expansion to actions like 'disable_modeling'."
   },
   "new_filter_targetfieldname": {
      "text": "A string expecting a field name. The filter will apply on all results for the targetFieldName value the ruleConditions apply. When empty, filtering applies only to results for which the ruleConditions apply."
   },
   "new_action_targetfieldvalue": {
      "text": "A string expecting a value for targetFieldName. If any of the ruleConditions apply, all results will be excluded for that particular targetValue but not for others. Can only be specified if targetFieldName is not empty."
   },
   "new_action_conditionsconnective": {
      "text": "The logical connective of the ruleConditions."
   },
   "new_action_ruleconditions": {
      "text": "The list of conditions used to apply the rules."
   },
   "new_action_conditiontype": {
      "text": "A string specifying the condition type."
   },
   "new_action_fieldname": {
      "text": "A string specifying the field name on which the rule applies. When empty, rule applies to all results."
   },
   "new_action_fieldvalue": {
      "text": "A string specifying the numerical field value on which the rule applies. When empty, rule applies to all values of fieldName. Can only be specified if fieldName is not empty."
   },
   "new_action_condition": {
      "text": "The condition comparing fieldValue and value."
   },
   "new_action_value": {
      "text": "The numerical value to compare against fieldValue."
   },
   "new_action_valuelist": {
      "text": "A string that is a unique identifier to a list. Only applicable and required when conditionType is categorical."
   }
}


